# algorithm

## recursion

关于递归写在前面
1. 虽然不强制必须写一个小的能解决单一问题的函数，例如mergeSort中，把两个有序的合并成一个新的有序的
又如快排中把第一个数移到左边的数都比他小，右边都比他大的地方，这些基础算法本身和递归无关，但有时候也挺难实现的
但记住，这不是递归的关键，把他分离成另一个函数可以减少你同时思考的量
2. 递归自己调自己，养成习惯这个函数开头就写判断，判断何时不再递归，
3. 递归能解决问题的关键在于那个判断的变量，虽然递归每次都调用一样的函数，但这个函数运行时的变量值肯定是变的，否则就是在无意义的重复
为了思路清晰，最好*把这个变化的变量作为递归函数的参数*
4. 递归思路（汉诺塔举例）
    1. 假设自己会那个比最大号问题小一号的问题，怎么获得最大号的问题的解（这时候你脑子肯定不知道小一号问题的解，但千万不要细想这点）
    （汉诺塔：你已经获得了移动n-1块的能力，你可以随便移动）
    2. 想最小问题如何解决，并把它写在递归函数的开头判断上（汉诺塔：移动一块）
    3. 相信自己，现在你已经可以知道怎么解决问题了，不管你现在内心是否清晰
    
### fully arrange
### Tower of Hanoi
### big integer multiply
略复杂，主要理解概念，具体其实只要没超过int最大值，用内置乘法还是最快
### Strassen matrix multiplication
数学问题啊啊啊啊啊，，太难了，放弃
### merge sort
### quick sort

## 
